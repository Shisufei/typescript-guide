# 第一节 - 类型

类型系统是 TypeScript 的核心, 在这一节, 我们会按照由简单到不那么简单的顺序学习相关语言特性.

如非特别说明, 所有例子中任意变量都具备直接标注的类型或能被 TypeScript 类型系统推导出的类型.

**请在阅读例子的同时思考类型系统是如何进行类型推导的.**

## 基本特性

### 特殊类型

- 四个原始值类型 `string`, `number`, `boolean`, `void` (对应 `undefined` 或 `null`).
- 任意类型 `any`.

### 使用举例

#### 变量

```typescript
var abc: string;
var ghi = '...';
// 冗余的类型标注, 不推荐使用.
var def: string = '...';
```

#### 函数

```typescript
// 推荐总是显式标注返回值类型.
function explicitReturnType(a: string, b: number): number {
    return 0;
}

function implicitReturnType(a: RegExp) {
    return a.test('biu!');
}

function optionalArguments(a: string, b?: number) {
    // ...
}
```

#### 接口

```typescript
interface Whatever {
    abc: string;
    /** 可选成员 */
    def?: string;
}

var nonsense: Whatever = {
    abc: 'biu!'
};

foo(nonsense);

function foo(options: Whatever): string {
    return options.abc + (options.def || '');
}
```

#### 类

```typescript
class Nonsense {
    abc: string;
    def = 'some text';
    
    constructor(abc: string) {
        this.abc = abc;
    }
    
    test(): boolean {
        return this.abc == this.def;
    }
}

var whatever = new Nonsense('hello');

whatever.test();
```

#### 数组

```typescript
var arr: string[] = [];
var arr = ['abc'];

var matrix: number[][] = [];
var matrix = [[1, 2], [3, 4]];
```

## 常用特性

### 使用举例

#### 函数

```typescript
/** 箭头函数 */
var foo = (str: string) => {
    return str.length;
};

// 当箭头函数中仅有一个 return 语句时, 可以简写为:
var foo = (str: string) => str.length;

// 或显式声明返回值类型:
var foo = (str: string): number => str.length;

foo('biu!');

// 当箭头函数仅有一个形参, 并且无需标注类型时, 可以省略圆括号:
window.onload = event => {
    // 在这个例子中, 类型系统通过 window.onload 的类型推导出了 event 的类型.
    console.log(event.type);
};

// 结合上面两种简写:
var names = [1, 2, 3].map(n => 'name-' + n);

/** 函数重载 */
function overload(a: string, b number): void;
function overload(b: number): void;
function overload(a: any, b?: number) {
    if (typeof a === 'number') {
        b = a;
        a = undefined;
    }
}
```

#### 接口

```typescript
/** 函数接口 */
interface FunctionInterface {
    (a: string, b: number, c?: boolean): void;
}

var fn: FunctionInterface = (a, b, c) => {
    console.log(a.substr(b));
};

/** 哈希表接口 */
interface MapInterface {
    [key: string]: number;
}

// 思考: 如果不加 `: MapInterface` 会有什么不同?
var map: MapInterface = {
    abc: 0,
    def: 1
};

console.log(map['abc']);

/** 接口扩展 */
interface BaseA {
    abc: string;
}

interface BaseB {
    def: number;
}

interface Extended extends BaseA, BaseB {
    ghi: boolean;
}

var whatever: Extended = {
    abc: 'biu!',
    def: 123,
    ghi: true
};
```

#### 类

```typescript
class Nonsense {
    abc: string;
    /** 私有成员, 只能在当前类中访问 */
    private def: number;
    /** 受保护的成员, 只能在当前类和当前类的派生类中访问 */
    protected ghi: boolean;
    
    /**
     * @param foo 定义参数的同时定义同名私有成员.
     * @param bar 定义参数的同时定义同名公有成员.
     */
    constructor(
        private foo: RegExp,
        public bar: string
    ) { }
    
    test() {
        var fn = () => {
            // 箭头函数不改变 this 上下文.
            var regex = this.foo;
            var value = this.bar;
            return regex.test(value);
        };
        
        return fn();
    }
}

/** 继承类 */
class CommonSense extends Nonsense {
    constructor(foo: RegExp, bar: string) {
        super(foo, bar);
    }
    
    fire(): void {
        console.log(this.ghi);
    }
}

/** 实现接口 */
interface Face {
    abc: string;
    foo(str: string): number;
}

class Implementation implements Face {
	abc: string;
    foo(str: string): number {
        this.abc = str;
        return str.length;
    }
}
```
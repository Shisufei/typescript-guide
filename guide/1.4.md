# TypeScript 1.4 新增特性

## 联合类型及类型收窄 (Union Types and Type Guards)

https://github.com/Microsoft/TypeScript/pull/824

### 联合类型

在之前的 TypeScript 版本中, 如果需要表示多种可能的类型, 很多时候不可避免地需要用到 `any`. 但现在不必了:

```ts
var stringOrNumber: string|number = '';
stringOrNumber = 0;

// 无错误:
stringOrNumber.toString();
// 报错, 因为只有 string 有 substr 方法:
stringOrNumber.substr(0);
```

联合类型只能使用多个类型共有的方法和属性, 如果需要使用其中某种类型特有的成员, 则需要先进行[类型收窄](#类型收窄), 而当类型收窄无法满足具体情况时, 可以使用类型转换:

```ts
var stringOrNumber: string|number = '';
(<string>stringOrNumber).substr(0);
```

### 类型收窄

对于联合类型, 我们可以通过一些控制语句进行类型收窄 (Type Narrowing):

```ts
var value: string|number|Date = '';

if (typeof value === 'string') {
    // 在这个 if 分支中 value 为 string.
} else if (typeof value === 'number') {
    // 在这里 value 为 number.
} else {
    // 在这里 value 为 Date 类型.
}

if (value instanceof Date) {
    // 在这里 value 为 Date 类型.
}
```

但实际使用时, 类型收窄还会有诸多限制, 比如如果在 `if` 分支中尝试给对应变量赋值, 会使其回退到没有收窄前的类型:

```ts
var value: string|number|Date = '';

if (typeof value === 'string') {
    // 报错, 此时 value 回退到 string|number|Date 类型,
    // 不能直接使用 string 特有的 substr 方法.
    value = value.substr(0);
}
```

读者可能记得之前提到的 TypeScript 的类型检查只关注值的 "外形". 而这个原则给类型收窄带来了一点小 "麻烦":

```ts
var value: string|Date;

if (value instanceof Date) {
    // 在这里 value 为 Date 类型, 意料之中.
} else {
    // 而在这里, value 却是 string|Date, 而非我们期望的 string.
}
```

原因很简单, 因为即便不是 Date 的实例, value 也可能拥有 Date 类型所有的方法和属性. 而这对于只看 "外形" 的 TypeScript 类型检查来说是等价的.

好消息是 TypeScript 1.6 中加入了自定义类型判定函数 (Custom Type Guard Functions), 可以实现更灵活的判断和类型收窄.

## Let 和 Const 语句

https://github.com/Microsoft/TypeScript/pull/904

## 模板字符串 (Template String)

https://github.com/Microsoft/TypeScript/pull/960

## 常量枚举类型 (Const Enums)

https://github.com/Microsoft/TypeScript/issues/1029

在 TypeScript 1.4 中, 出于性能考虑, 在原有枚举特性的基础上加入了 `const enum`:

```ts
const enum ASTType {
    program,
    expression,
    operator
}

var typeProgram = ASTType.program;
```

**默认配置下**, 编译后将只有一行输出:

```js
var typeProgram = 0 /* program */;
```

请读者自行对比加与不加 const, 编译结果的区别.

除了性能考虑之外, 使用 `const enum` 也可以避免由于模块互相引用带来的与之相关的问题.

---

&lt; [1.3 新增特性](1.3.md) | [1.5 新增特性](1.5.md) &gt;